\chapter{Mining Pools}\label{mining-pools}

\section{Funzionamento generico}

Un utente fondamentale per l'ecosistema bitcoin è il miner, ovvero colui che si occupa di cercare nuovi blocchi in modo da rafforzare la catena. Dato che tale ricerca richiede tempo e soprattutto consumo di corrente elettrica a causa dei complicati calcoli crittografici interessati, ogni scoperta di un nuovo blocco viene premiato con un quantitativo di BTC predefinito.
Il tipo di attività, il nome di questi nodi e la ricompensa in denaro che ne deriva fanno subito venire in mente un'analogia con i minatori d'oro, che impiegano il loro tempo e il loro duro lavoro per estrarre il prezioso metallo.
Mantenendo tale analogia, è evidente come un minatore da solo, pur impegnandosi al massimo delle sue possibilità, non sia in grado di estrarre tanto oro quanto più minatori riuniti in una compagnia mineraria. La controparte Bitcoin delle compagnie minerarie sono le \emph{mining pools}, società private che si prendono il merito del ritrovamento del blocco, ma dividono la ricompensa con quei miners associati che hanno contribuito al ritrovamento.
Per sapere quanto conviene associarsi ad una mining pool piuttosto che ad un'altra è necessario fare alcuni calcoli.

Definiamo quindi i seguenti dati:
\begin{description}
    \item[$B$] Ricompensa derivata dal ritrovamento del blocco. Viene dimezzata quando abbastanza blocchi vengono trovati, in modo da limitare il numero massimo di BTC a 21 milioni. Inizialmente era di 50 BTC a blocco, ma al momento della stesura è di 25 BTC.
    \item[$D$] Difficoltà nel ritrovamento di un blocco, ovvero il rapporto tra il massimo possibile valore teoricamente possibile per l'hash di un blocco e il massimo hash attualmente consentito detto target. Tale valore viene automaticamente aggiustato dalla rete ogni 2016 blocchi alzando o abbassando il target in modo che venga trovato circa un blocco ogni 10 minuti. In pratica tale valore deve essere calcolato in modo che ogni hash abbia una probabilità pari a $\frac{1}{2^{32} D}$\footnote{Il valore reale di probabilità è $\frac{2^{16} - 1}{2^{48} D}$, ma come osservato da Meni Rosenfeld in \cite{pool-analysis}, l'approssimazione proposta risulta sufficientemente accurata ai fini dell'analisi.} di essere un blocco valido.
    \item[$h$] Hashrate di un nodo, ovvero il numero di hash calcolati nell'intervallo di tempo $t$.
\end{description}
Con questi dati presenti, possiamo dire che un singolo miner con hashrate $h$ nell'intervallo di tempo $t$ potrà calcolare un totale di $ht$ hash e quindi una media di $\frac{ht}{2^{32}D}$ blocchi portandolo ad incassare $\frac{htB}{2^{32} D}$ BTC.

Ricercare un blocco in solitario, con hashrate fisso, è un processo di Poisson con intensità $\lambda_r = \frac{h}{2^{32}D}$ (come già accennato in \ref{misurazioni}), per cui il numero di blocchi trovati nel tempo rispetta la distribuzione di Poisson con parametro $\lambda = t\lambda_r = \frac{ht}{2^{32}D}$\footnote{$\lambda_r$ è un parametro di un processo di Poisson detto \emph{intensità} studiato in modo che tale processo rispetti la distribuzione di probabilità di Poisson con parametro $\lambda = \lambda \cdot \tau$, dove $\tau$ è il tempo trascorso dall'inizio dell'osservazione.}.
Tale $\lambda$ risulta essere anche la varianza\footnote{Per un valore casuale, la varianza $\sigma^2$ è una misura della tendenza che ha tale valore di discostarsi dal suo valore atteso. Di quanto si discosta è stabilito dalla deviazione standard $\sigma = \sqrt{\sigma^2}$.} di questa distribuzione. La varianza del pagamento atteso è $\lambda B^2 = \frac{htB^2}{2^{32}D}$ e la relativa deviazione standard, espressa come frazione del pagamento atteso, è $\frac{\sqrt{\lambda B^2}}{\lambda B} = \frac{1}{\sqrt{\lambda}} = \sqrt{\frac{2^{32}D}{ht}}$.

\begin{esempio}
Bob possiede un computer dedicato in grado di calcolare un miliardo di hash al secondo, $h = 1Gh/s = 10^9 h/s$. Utilizzandolo per un giorno intero ($t = 86400s$) a difficoltà $D = 1690906$ con ricompensa $B = 50BTC$, troverà in media $\frac{ht}{2^{32}D} \approx 0.0119$ blocchi ricevendo in pagamento $0.0119B = 0.595$ BTC.
Bob si trova però con una varianza nel pagamento di $0.0119B^2 = 29.75 \text{BTC}^2$, con una deviazione standard di $\sqrt{29.75 \text{BTC}^2} \approx 5.454 \text{BTC}$, ovvero il 917\% del guadagno previsto. In effetti, la probabilità che alla fine della sua giornata di lavoro Bob abbia guadagnato qualcosa è solo del $1 - e^{-\lambda} \approx 1.18\%$, ben poco per ripagarlo dei soldi investiti nel computer dedicato e della corrente elettrica che esso ha consumato in quella giornata.
\end{esempio}

Come si nota, la varianza è un valore molto rilevante: un miner con hardware di tutto rispetto, se lavora da solo, potrebbe dover aspettare anche tre mesi prima di ricevere un qualsiasi pagamento, figurarsi per guadagnare effettivamente qualcosa. Inoltre è da notare come il mining sia un processo completamente casuale e privo di memoria: il fatto che siano passati tre mesi senza nessun risultato non rende più probabile il ritrovamento di un blocco, anzi, dovrà aspettare di media altri tre mesi. Se a questo si aggiunge la certezza che la difficoltà è pensata per aumentare nel tempo e di conseguenza anche la varianza, è evidente come diventare un miner solitario è estremamente infruttuoso. \\\\

Di contro, associarsi ad una mining pool ha notevoli vantaggi. Una pool infatti in media trova $\frac{Ht}{2^{32}D}$ blocchi nel tempo $t$, con una ricompensa media totale di $\frac{HtB}{2^{32}D}$, dove $H$ è l'hashrate totale a disposizione della pool. Un miner associato il cui hashrate è una frazione $h = qH$ dell'hashrate totale. dovrebbe ricevere $q$ volte la ricompensa totale, ovvero $q\frac{HtB}{2^{32}D} = \frac{htB}{2^{32}D}$ che è esattamente quanto si aspetta di ricevere nel caso in cui abbia lavorato da solo. Il vantaggio sta nella varianza estremamente ridotta: la varianza totale è $\frac{HtB^2}{2^{32}D}$, per cui la varianza per il singolo è $q^2 \frac{HtB^2}{2^{32}D} = q\frac{htB^2}{2^{32}D}$ che corrisponde a $q$ volte la varianza di un minatore solitario. Il beneficio per un minatore è quindi direttamente proporzionale alla dimensione della pool a cui si associa e inversamente proporzionale alla potenza di calcolo che mette a disposizione della pool.

Una mining pool di solito viene gestita da un operatore il quale prende una tariffa per i servizi offerti, solitamente una percentuale fissa $f$ sulla ricompensa derivata dal ritrovamento dei blocchi. Quindi per ogni blocco l'operatore si intasca $fB$ BTC distribuendo $(1-f)B$ ai minatori, per cui il ricavo atteso di un singolo minatore risulta $\frac{(1-f)htB}{2^{32}D}$.
Per stabilire quanto si è contribuito al mining della pool, i minatori trovano e inviano delle fette (\emph{shares}), ovvero hash di un blocco che avrebbero rappresentato un blocco vero se la difficoltà fosse stata pari a 1. Ogni hash calcolato ha una probabilità di $\frac{1}{2^32}$ di essere una share e, assumendo che la funzione di hash sia corretta, dato che è impossibile trovare share senza effettuare gli stessi calcoli necessari per trovare un blocco e anche trovare un blocco senza trovare delle share nel tentativo, il numero delle share trovate da un singolo miner è mediamente proporzionale al numero di hash calcolate dallo stesso miner nel tentativo di trovare un blocco per la pool.\\
Dato che una share ha una probabilità $p = \frac{1}{D}$ di essere un blocco valido, se un minatore lavorasse da solo il ritrovamento di una share gli frutterebbe $pB$, ammesso e non concesso che riesca a trovare il relativo blocco per primo. Impegnandosi in una pool impiegherebbe le stesse risorse e riceverebbe la stessa quantità per ogni share inviata\footnote{$(1-f)pB$ tenendo conto della tariffa dell'operatore.} nel caso in cui un membro qualsiasi della pool trovi il blocco, il che è un evento decisamente più probabile di quello in cui lui da solo trovi il blocco.\\

La differenza tra le varie pool sta nel modo in cui la ricompensa viene divisa tra i minatori. Infatti se l'hashrate di un minatore è troppo basso, la sua varianza influenza il numero di shares che è in grado di trovare, per cui non tutti i minatori troveranno la stessa pool adatta alle loro esigenze, a causa dei differenti sistemi di retribuzione che sono implementati sulle diverse pool. Inoltre anche il mining discontinuo influenza la varianza in un modo che a sua volta dipende dal sistema di ricompensa.
In ogni caso tali considerazioni non hanno effetto sulla quantità del pagamento medio, che risulta sempre essere $(1-f)pB$ per ogni share inviata.

\section{Sistemi di retribuzione semplici}

\subsection{Proporzionale}\label{pool-proporzionale}

In questo sistema, i pagamenti sono calcolati in base ad una divisione in \emph{round}, dove un round è il tempo che intercorre tra due ritrovamenti di blocchi da parte della pool. Alla fine di ogni round, quando il blocco viene ritrovato e la pool riceve la relativa ricompensa, l'operatore trattiene la sua parte e distribuisce il resto tra i minatori in proporzione diretta al numero di share da loro sottoposte durante il round. Se un minatore ha inviato $n$ share il numero totale di share ricevute dalla pool è $N$, allora il pagamento di tale minatore per il round è $\frac{n}{N}(1-f)B$.
La varianza per ogni share è approssimativamente $p^2 B^2 \ln{D}$, dato che la varianza per un minatore solitario è $pB^2$ per share, si tratta di un miglioramento di un fattore pari a $\frac{D}{\ln{D}}$. Questo vale unicamente per piccoli miners. Per i miner più importanti la varianza totale non può scendere sotto un valore che è $q$ volta la varianza del singolo minatore, dove $q=\frac{h}{H}$ è la frazione di potere computazionale della rete fornito dal minatore.
Inoltre tali risultati sono validi solo nel caso in cui il numero di minatori sia costante. Dato che un minatore può essere in grado di stabilire quando è conveniente o meno calcolare blocchi in associazione con una mining pool, è frequente il caso di minatori che si collegano fin quando conviene a loro e si scollegano appena il gioco non vale la candela, pratica detta \emph{pool-hopping} e che permette ai minatori che la sfruttano di guadagnare in quantità superiore alla media per ogni share a discapito di quei minatori che invece contribuiscono in modo continuo alla pool che si troveranno a ricavare meno BTC dal loro lavoro.
Nelle pool proporzionali, il pool-hopping funziona particolarmente bene: il pagamento per ogni share, a meno delle tariffe dell'operatore per semplicità, è $\frac{B}{N}$, per cui più lungo risulta essere il round, meno si guadagna per ogni share. È quindi evidente come un minatore possa guadagnare di più se invia le proprie share durante i round più corti e cambia pool durante quelli lunghi.
Ovviamente nessuno può predire il futuro, ma il passato è ben noto: il numero di share che sono già state inviate nel momento in cui si decide se unirsi o meno ad una pool offre una buona stima di quanto possa ancora essere lungo il round. Ad esempio, se sono già state inviate $2D$ shares, allora chiaramente entro la fine del round si avrà $N \geq 2D$ portando il pagamento per ogni share a meno di $\frac{pB}{2}$, una situazione decisamente poco remunerativa.
Se lavorare per tutto il round porta una ricompensa normale e lavorare solo tardi nel round porta una ricompensa minore, allora è ovvio come lavorare all'inizio del round porti una ricompensa superiore alla media. Secondo Rosenfeld, il punto in cui il pagamento atteso è uguale al pagamento medio si ha quando il numero di share già caricate è il 43.5\% della difficoltà: un pool-hopper si sforzerà quindi di collaborare solo prima del raggiungimento di tale valore e per poi abbandonare la pool e magari ritornare in un nuovo round.

Il problema del metodo proporzionale sta nella sua natura deterministica che molto si discosta dalla natura del problema del ritrovamento di un blocco, un processo del tutto casuale. Infatti il numero di share per round segue una distribuzione geometrica (con parametro di successo $p$ e media aritmetica $D$), la quale è priva di memoria: ci saranno una media di $D$ shares in ogni round e se un numero $I$ di tali share è già stato inviato, il numero di share rimanenti non diminuisce, ma segue sempre la stessa distribuzione risultando in mediamente altre $D$ shares da trovare. Ogni nuova share dovrà competere con le $I$ precedenti e con le $D$ future, per cui per migliorare le probabilità di guadagno è importante che l'unico parametro controllabile $I$ sia il più basso possibile, il che equivale a collegarsi ad una pool all'inizio del round.
Una conseguenza del pool-hopping è che i nodi onesti, che rimangono in una pool per tutta la durata del round, possono teoricamente nel caso peggiore guadagnare fino al 43\% in meno rispetto al guadagno atteso, una situazione assolutamente inaccettabile che mette bene in evidenza gli svantaggi di un metodo proporzionale.

\subsection{Pay-Per-Share (PPS)}

In questo sistema l'operatore non è semplicemente un fornitore di servizi, ma si assorbe tutta la varianza che altrimenti dovrebbero affrontare i minatori: quando uno di esse carica una share, l'operatore immediatamente lo paga con $(1-f)pB$ BTC, ovvero con l'intero valore atteso, ma una volta che il blocco viene trovato l'operatore si tiene tutta la ricompensa.
Si tratta quindi di un sistema deterministico in cui il guadagno è noto a priori, portando diversi vantaggi per i minatori:
\begin{itemize}
    \item Nessuna varianza nella ricompensa per singola share. Esiste comunque una varianza nel numero di share trovate, ma è insignificante.
    \item Nessun ritardo nei tempi di pagamento, in quanto non serve aspettare il ritrovamento del blocco.
    \item Facile verificare che il pagamento sia avvenuto e che sia nel giusto ammontare.
    \item Nessuna perdita dovuta a pool-hopping, inefficace con tale sistema.
\end{itemize}
D'alto canto questi vantaggi sono solo per i minatori, per l'operatore il rischio è invece molto elevato. Come per i minatori nel metodo proporzionale, l'operatore può guadagnare molto in caso di round brevi (in quanto riceve l'intero ammontare della ricompensa pagando solo poche shares) mentre per round lunghi può anche risultare in perdita in modo sostanziale. La sua varianza è infatti la stessa di un minatore solitario il cui hashrate è uguale a quello dell'intera pool. Per compensare tale rischio l'operatore solamente richiede tariffe più alte rispetto agli altri sistemi, e questo è il solo svantaggio a carico dei minatori.
A causa dell'elevato rischio, se l'operatore non è oculato nella gestione delle sue finanze la pool può andare in bancarotta. Rosenfeld ha calcolato che per tenere il rischio di bancarotta sotto una certa soglia $\delta$, l'operatore deve mantenere una quantità di BTC di riserva almeno pari a
\[R = \frac{B \ln\frac{1}{\delta} }{2f}\]
Tale valore è solitamente più elevato di quanto un novello operatore si aspetta, per cui è importante che egli sia un oculato gestore delle proprie finanze prima di assumersi la responsabilità di aprire un tale tipo di pool. I minatori d'altronde prima di iscriversi a questo tipo di pool dovrebbero verificare le competenze dell'operatore, in modo da non rischiare di perdere i propri guadagni a causa di una bancarotta improvvisa.

\section{Sistemi di retribuzione a punteggio}

\subsection{Metodo di Slush}\label{pool-slush}

Prende il nome dalla pool in cui fu per la prima volta implementato ed è il primo metodo progettato con l'obiettivo di rendere inefficiente il pool-hopping.
Si basa sempre sul metodo proporzionale, ma invece di basare le retribuzione sulla semplice conta delle shares, attribuisce uno \emph{score} ad ogni share in base al quale verrà distribuito il premio per il ritrovamento del blocco alla fine del round.
Il punteggio è in relazione diretta al tempo trascorso dall'inizio del round, in modo da contrastare l'effetto visto nel metodo proporzionale. La funzione di score è esponenziale: $s=e^{\frac{T}{C}}$ dove $s$ è lo score assegnato per una share caricata all'istante $T$ e $C$ è una costante.
Tale funzione garantisce che ad un certo punto dopo l'inizio del round si raggiunga uno stato stabile in cui non è più rilevante l'istante in cui una share viene condivisa in quanto lo score attribuito risulta essere identico così come di conseguenza la ricompensa.
Il parametro $C$ controlla la velocità con cui si raggiunge tale stato di stabilità o, equivalentemente, la velocità con cui il punteggio decade in relazione alle shares. Se $C$ è basso il decadimento è rapido, ovvero ogni share ha una elevata possibilità di non ricevere nessun pagamento nel caso di lunghi round. Per round brevi invece il pagamento sarà molto elevato perché non sarà condiviso con molte altre share.
Il risultato è che valori bassi di $C$ aumentando notevolmente la varianza dei pagamenti ricevuti, riducendo però la vulnerabilità al pool-hopping.
Nonostante la sua importanza storica, tale metodo ha diversi aspetti negativi:

\begin{itemize}
	\item Il punto di stabilità viene raggiunto solo ad un certo punto nel round, il che vuol dire che si ripresentano gli stessi problemi del metodo proporzionale relativi a quando associarsi alle mining pools. Sebbene l'effetto non sia altrettanto drastico, la conseguenza è un diretto fallimento delle premesse del metodo che non risulta completamente resistente al pool-hopping.
	\item Dato che lo score dipende dal tempo e non dal numero di share, il metodo è soggetto ad hopping dovuto a fluttuazioni nell'hashrate.
	\item Nel calcolo del punteggio non si tiene conto della difficoltà nel trovare un blocco, quindi il metodo può subire hopping derivato dai cambiamenti previsti nella difficoltà.
\end{itemize}

Il primo problema è il più grave in quanto è un caso di un problema più generale: un sistema che ad ogni divide una ricompensa in modo proporzionale tra i minatori partecipanti al round può essere immune al pool-hopping solo se retribuisce la share che ha risolto il round, il che risulta equivalente al mining in solitario e quindi indesiderabile a causa dell'elevata varianza. Tale affermazione è nota come \emph{teorema dell'immunità da hopping}, dimostrato da Rosenfeld nell'appendice D di \cite{pool-analysis}.

\subsection{Metodo Geometrico}

Una evoluzione del motodo di Slush che risulta essere immune da hopping.
In questo metodo esistono due tipi di tariffe, una fissa e una variabile. La tariffa fissa viene scalata dalla ricompensa di ogni blocco, mentre quella variabile è un punteggio assegnato automaticamente all'operatore all'inizio di ogni round e che decade nel tempo esattamente come il punteggio dei minatori.
Questo porta alla creazione di uno stato stabile in cui il punteggio per ogni share rimane costante eliminando le differenze derivanti dai tempi di condivisione delle share. L'algoritmo \ref{alg_metodo_geometrico} illustra il funzionamento del metodo.

\input{./tex/metodogeometrico.tex}

Come per gli altri metodi, la tariffa fissa permette all'operatore di intascare $fB$ sulla ricompensa del blocco, mentre sul rimanente $(1-f)B$ viene applicata la tariffa variabile permettendogli di guadagnare un ulteriore $c(1-f)B$. Complessivamente quindi la tariffa vale in media $c + f -cf$ e di conseguenza un operatore prende in media $(c+f-cf)B$  per blocco mentre il restante $(1-c)(1-f)B$ viene diviso tra i miners a seconda del loro punteggio.
Viene utilizzato un contatore dei round $s$ che verrà utilizzato come multiplo di $pB$, in modo da far decadere in modo esponenziale il valore delle prime shares del round mano a mano che questo procede.
Il rateo di decadimento è indicato da $r$, che imposta il punteggio per ogni share come $r$ volte il punteggio della share precedente. A difficoltà fissa $r$ rimane costante in modo che il punteggio dell'$I$-esima share sia $r^{I-1}pB$. Più basso è $r$ maggiore deve essere il punteggio dell'operatore per mantenere una situazione stabile, per cui maggiore è anche la tariffa variabile.
A difficoltà e ricompensa costanti, se $N$ è il numero complessivo di share sottoposte nel round, allora $s=r^N$ e il pagamento medio per un minatore risulta essere
\[ \frac{(1-f)(r-1)S_k}{sp} = \frac{S_k}{\frac{r^N pB}{r-1}}(1-f)B = \frac{S_k}{\sum^N_{i=-\infty}r^{i-1}pB}(1-f)B \]
che è equivalente a distribuire $(1-f)B$ in proporzione al punteggio, se l'operatore riceve un punteggio di $\sum^0_{i=-\infty}r^{i-1}pB = \frac{pB}{r-1}$ e il punteggio complessivo di tutti i partecipanti è $\sum^N_{i=-\infty}r^{i-1}pB$.
Lo scopo di ciò è fare in modo di assegnare un numero infinito di share all'operatore all'inizio di ogni round. Così facendo, ogniqualvolta un miner invia una share essa sarà l'ultima di una serie infinita il cui punteggio decade in modo esponenziale nel tempo, permettendo quindi di mantenere fisse le proprietà statistiche della share appena inviata.
Dato che il pagamento atteso per ogni share è $(1-f)(1-c)pB$ la varianza risulta essere approssimativamente $\frac{(pB)^2}{2c+p}$, una riduzione di circa $1+\frac{2c}{p}$ rispetto alla varianza $pB^2$ di un minatore solitario. L'operatore si trova in modo similare con una varianza per blocco di circa $cB^2$.
Se la tariffa media complessiva $c+f-cf$ rimane costante durante il round a causa della diminuzione di $f$ e dell'aumento di $c$, la varianza per l'operatore viene aumentata mentre viene diminuita quella per i minatori, ma fintanto che $f$ rimane positivo l'operatore non rischia di subire alcuna perdita alla fine del round. Se però egli sceglie di assorbire maggiore varianza, può rendere negativo $f$ e aumentare ulteriormente $c$, aggiungendo di fatto le sue BTC personali alla ricompensa prevista dal ritrovamento del blocco: ciò significa che può arrivare a perdere fino a $(-f)B$ per blocco nei round più lunghi, ed impostando $f=\frac{-c}{1-c}$ la sua tariffa risulta pari a 0.
Nel caso limite in cui $c \rightarrow 0$, solo la share vincente verrà ricompensata e i minatori stanno a livello pratico lavorando in solitario.
Se invece $c+f-cf$ viene mantenuto fisso con $c \rightarrow 1$ e $f \rightarrow -\infty$, le varianze sopra citate sono trascurabili e il metodo si diventa equivalente al Pay-Per-Share: è quindi consigliato mantenere il valore di $c$ compreso tra 0 e 1.

Il metodo non è però semplice da mantenere nel caso in cui sia stato implementato in modo approssimativo, soprattutto a causa della crescita esponenziale di $s$, per cui è necessario prendere alcune precauzioni:
\begin{itemize}
    \item Resettare i punteggi: dato che quello che conta è il rapporto tra il punteggio dei lavoratori e il valore corrente di $s$, niente viene alterato se tutti questi punteggi vengono divisi per la stessa quantità. Per cui periodicamente è buona norma reinizializzare $\forall k S_k = \frac{S_k}{s}$ e successivamente $s=1$.
    \item Usare una scala logaritmica. L'algoritmo \ref{alg_metodo_geometrico} memorizza i valori reali di $s$ e $S$, che possono diventare molto elevati. Memorizzando i loro logaritmi $ls$ ed $lS$ ed adattando i calcoli si evita l'overflow di tali variabili. Una implementazione in tal senso è visibile nell'algoritmo \ref{alg_metodo_geometrico_log}.
\end{itemize}

\input{./tex/metodogeometricolog.tex}

\subsection{Pay-per-lst-N-shares (PPLNS)}

Non si tratta di un metodo solo, ma di una famiglia di metodi che si liberano del concetto di round finora visto.
Invece di distribuire le ricompense tra i partecipanti di un round, vengono distribuite tra i contributori recenti indipendentemente se sono stati trovati blocchi o meno nel periodo in esame. Così facendo si elimina il concetto di ``all'inizio del round'' e ne risulta che alcune varianti di PPLNS sono effettivamente immuni al pool-hopping.
La variante più semplice consiste nello stabile un numero fisso $N$ e pagare una ricompensa di $\frac{(1-f)B}{N}$ per ognuna delle ultime $N$ share inviate. Il pagamento per ogni share è $\frac{(1-f)BL}{N}$ dove $L$ è il numero di blocchi trovato nelle $N$ shares. Dato che ogni share ha una probabilità $p$ di essere un blocco indipendentemente dalle share passate, $L$ segue la distribuzione di Poisson cone media $\lambda = pN$, il che porta la ricompensa attesa a $\frac{(1-f)BpN}{N} = (1-f)pB$. La varianza di $L$ è $pN$ e di conseguenza la varianza per il pagamento atteso è $\frac{(1-f)^2 pB^2}{N} \approx \frac{pB^2}{N}$, ovvero $N$ volte migliore di quella di un minatore solitario.
La tempistica dei pagamenti è uniformemente distribuita lungo le $N$ shares in modo che ogni ricompensa venga ricevuta in media dopo $\frac{N}{2}$ shares, il che significa che il tempo medio di maturazione delle quote è $\frac{pN}{2}$. Aumentare $N$ riduce la varianza ma aumenta il tempo di maturazione, con l'invariante che il prodotto di questi due dati rimane costante a $\frac{(pB)^2}{2}$.
Nel caso in cui $D$ e $B$ non siano fissi, questa implementazione non è resistente al pool-hopping: i contributi di un minatore sono determinati dalla difficoltà corrente, mentre la sua ricompensa è influenzata dalla difficoltà futura, per cui i pool-hoppers possono utilizzare l'eventuale conoscenza di future fluttuazione nella difficoltà a loro vantaggio, unendosi quando la difficoltà è in prevista diminuzione e andandosene quando è previsto un aumento.\\\\
Una variante completamente resistente al pool-hopping è chiamata "unit-PPLNS" ed è descritta nell'algoritmo \ref{alg_unit_pplns}. In pratica viene tenuta traccia del valore di $p$ (chiamato \emph{unità}) e di $B$ (chiamato \emph{amplificatore}) per ogni share nel momento in cui questa viene ricevuta, il numero totale di unità $U^T$ e $U^T_k$ ovverto il valore di $U^T$ nel momento in cui è stata inviata la $k$-esima share.
Quando un blocco viene trovato e il valore corrente di $U^T$ viene memorizzato in $U^T_n$, per ogni share si ha $U=U^T_n - U^T_0$ in modo che le uniche share da ricompensare sono quelle per cui $U^T_0 > U^T_n - X -u_n$ dove $X$ è una finestra temporale in termini di unità e $u_n$ sono le unità della share che ha trovato il blocco. Di fondamentale importanza è garantire che la struttura dati utilizzata per $U^T$ e le misurazioni derivate possa supportare la precisione necessaria.
Il pagamento totale per ogni share è $\frac{(1-f)pBL}{X}$ dove $p$ è l'inverso della difficoltà, $B$ la ricompensa del blocco al momento ed $L$ è il numero dei blocchi trovati entro le prossime shares per un totale di $X$ unità. La probabilità di ogni share di essere un blocco è uguale alle sue unità e di conseguenza $L$ segue la distribuzione di Poisson con una media $\lambda = X$ indipendentemente dal passato o da ogni futura modifica della difficoltà. La ricompensa attesa per ogni share risulta essere $(1-f)pB$, la varianza approssimativamente $\frac{(pB)^2}{X}$ (migliorata di $\frac{X}{p}$ rispetto al minatore solitario), il tempo di maturazione è $\frac{X}{2}$ e il prodotto tra la varianza e il tempo di maturazione è $\frac{(pB)^2}{2}$.
La ricompensa attesa per una share come amplificatore $a$, $u$ unità e un totale di $U$ unità inviate dopo tale share è $\frac{(1-f)ua\max(X-U,0)}{X}$.\\\\
Dato che non esiste nessuna suddivisione in round in questa famiglia di metodi, un'operatore che volesse cambiare i parametri della pool non può farlo tra i round: deve modificarli in ogni share in modo da assicurare che le ricompense attese non cambino.
\begin{itemize}
  \item Per modificare le unità bisogna procedere in senso inverso dalla prima all'ultima share in modo da non alterare i valori di $U$.
  \item Se si intende modificare $f$ il metodo più semplice è ridimensionare l'amplificatore di ogni share di un fattore di $\frac{1-f_1}{1-f_2}$.
  \item La modifica di $X$ si devono riscalare le unità di ogni share di un fattore di $\frac{X_2}{X_1}$ e gli amplificatori di $\frac{X_1}{X_2}$. In questo modo i valori di $ua$ e di $\max(X-U, 0)$ rimangono invariati in ogni share.
\end{itemize}
Ogni altro metodo di cambiamento (in particolare in caso di riduzione di $X$) potrebbe portare a situazioni in cui per qualche share si ha $U > X$ e quindi nessun cambiamento nei suoi valori è in grado di mantenere uguale la ricompensa attesa e l'operatore si vede costretto a pagare immediatamente il valore atteso: una sorta di pagamento per il ``prestito statistico'' che ha sottoscritto quando ha aperto la pool con un valore di $X$ troppo elevato.

\input{./tex/alg_unit_pplns.tex}

\section{Pay-per-share privo di rischi}\label{pool-famiglia-mpps}

L'attrattiva del metodo PPS per i minatori, in contrasto con l'elevato rischio per gli operatori, ha generato molti tentativi di implementazione che mimino il PPS ma con ricompensa di tipo \emph{best-effort} in base alla fortuna della pool.

\subsection{Maximum Pay-Per-Share (MPPS)}

In questo metodo vengono mantenuti due bilanci separati per ogni partecipante, un bilancio PPS e un bilancio proporzionale. Ogniqualvolta un minatore invia una share, il suo bilancio PPS viene incrementato come se fosse una pool PPS. Quando viene trovato un blocco, il bilancio proporzionale di ogni minatore viene incrementato come se fosse una pool omonima. Il pagamento che spetta ad ogni partecipante è il minimo tra i due bilanci.\\
L'idea alla base di tale sistema è, dato che il totale del bilancio proporzionale di tutti i minatori è uguale alla ricompensa totale ottenuta dalla pool e il pagamento che viene elargito ai minatori è minore di questa quantità, la pool non potrà mai andare in perdita. Inoltre, dato che il bilancio PPS di un minatore è un accumulo della ricompensa media per ogni share trovata, non può utilizzare il pool-hopping per ottenere una ricompensa più alta di quella media: i round corti non pagano grandi ricompense nell'immediato, bensì riempiono una sorta di buffer del minatore per aiutare i pagamenti durante i round più lunghi.
Purtroppo tale metodo ha un clamoroso difetto. Innanzitutto, dato che il totale ammontare pagato è il minimo di due differenti bilanci, ognuno dei quali ha un valore atteso uguale alla media, ne consegue che il pagamento atteso risulta sempre minore alla media: la ricompensa per il minatore è normale in caso di round fortunati e minore del normale in tutti gli altri casi.
Rosenfeld ha quantificato che in media la porzione di ricompensa persa risulta essere $\frac{1}{\sqrt{2\pi n}}$ nel caso in cui un minatore si unisca ad una pool MPPS e collabori per tutto il tempo necessario alla pool per trovare $n$ blocchi. Mano a mano che il minatore rimane nella pool le perdite relative diminuiscono sensibilmente (nonostante aumentino in senso assoluto), infatti nel caso in cui $n=10$ le perdite ammontano a circa il 12.6\%.

\subsection{Shared maximum Pay-Per-Share (SMPPS)}

Con questo metodo si tenta di risolvere il problema di MPPS rimpiazzando il buffer per-utente con un buffer globale condiviso tra tutti gli utenti. Round corti riempiono il buffer, aiutando la pool ad elargire i pagamenti PPS durante i round più lunghi. Una volta che il buffer si esaurisce tutti i pagamenti PPS vengono ritardati fin quando non vengono raccolti abbastanza fondi. Come questo viene fatto dipende dall'implementazione specifica della pool.
Nella sua concezione originale, la pool tiene traccia della ricompensa spettante ad ogni minatore: quando una share viene inviata la ricompensa viene incrementata come se la pool fosse PPS, mentre per elargire un pagamento esso viene dedotto da tale ammontare. La pool tiene inoltre traccia del suo buffer $R$, definito come la differenza tra il totale dei guadagni derivati dal ritrovamento dei blocchi e il totale PPS dovuto ai minatori.
Nel caso in cui $R < 0$, ovvero esistono partecipanti creditori della pool che non possono essere pagati per mancanza di fondi, il totale dovuto ai minatori è $-R$, per cui appena un blocco viene trovato la sua ricompensa viene divisa tra tutti i minatori in proporzione a quanto loro dovuto: un minatore a cui si deve $w$ si verrà pagato $\frac{wB}{-R}$.
Il primo inconveniente con questo metodo si ha quando $R<0$: il tempo di maturazione\footnote{Tempo medio necessario espresso in numero di blocchi per ricevere il pagamento da parte della pool.} diventa tanto più elevato quanto $R$ si riduce, essendo approssimabile a $\frac{-R}{B}$.
Il secondo problema è che sicuramente il buffer prima o poi raggiungerà livelli arbitrariamente bassi ovvero, se la pool continua ad operare indefinitamente, esiste una probabilità del 100\% che ad un certo punto il buffer sarà di $-1000$ BTC, ma anche che in un altro momento sarà $-10000$ BTC e via dicendo. Quando il debito diventa sufficientemente alto, il tempo di maturazione sarà talmente elevato che probabilmente i minatori non vedranno mai alcun pagamento, abbandoneranno la pool aggravando quindi il problema, in quanto riducendo l'hashrate aumenta il tempo necessario per trovare un blocco e di conseguenza il tempo di maturazione quando misurato in tempo reale. Quando questa spirale distruttiva entra in scena, chiunque abbia un qualche credito con la pool non lo vedrà mai saldato.
Un terzo problema è che tale collasso accadrà prima del previsto: inefficienze quali blocchi invalidi, sabotaggi, shares non aggiornate (quando pagate) e via dicendo non fanno altro che ridurre il guadagno atteso da ogni share, provocando un lento ma inesorabile declino del livello del buffer.
Infine, questo metodo non è immune da hopping: mentre il pagamento atteso per ogni share è in teoria fisso, il tempo di maturazione non lo è. Lavorare per la pool mentre il buffer è positivo è conveniente in quanto è essenzialmente una PPS senza tariffe, quando il buffer è negativo non è conveniente a causa dell'elevato tempo di maturazione, per cui i minatori tenderanno a lavorare in situazioni di buffer pieno e ad abbandonare la pool altrimenti, lasciando ai minatori onesti tutto il peso del buffer vuoto e invogliando anche essi a lasciare la pool per lidi più feritili.

\subsection{Equalized shared maximum Pay-Per-Share (ESMPPS)}

Si tratta di una variante del metodo precedente basata sull'idea che un seppur minimo pagamento per la share vada elargito appena possibile, mettendo in secondo piano il pagamento completo.
In tale metodo, la pool tiene traccia di tutte le share inviate e quanto è dovuto per ognuna di essere. Tali shares vengono pagate in toto fino a quando la pool ha sufficienti fondi, in caso ciò non sia possibile appena viene trovato un blocco la ricompensa viene divisa tra tutte le share in modo da massimizzare il pagamento minimo elargito ad ognuna di esse (ovvero, si da la priorità alle share che sono state pagate di meno).
Grazie a questo meccanismo, anche se il pagamento dovuto diventa molto grande, le nuove share possono velocemente raggiungere il livello di pagamento di quelle più vecchie. Ma una volta che tale livello di pagamento diventa sufficientemente alto è molto difficile che tale livello aumenti ulteriormente, per cui è molto difficile che la pool saldi al 100\% i suoi debiti\footnote{In effetti, gli operatori di tali pool non considerano il pagamento completo un obiettivo raggiungibile, ma puntano piuttosto a valori attorno al 97\%}. Come conseguenza, il tempo di maturazione di questo metodo è di fatto infinito.
Il vantaggio di ESMPPS sta nel modo graduale con cui gestisce le perdite. Le inefficienze riducono il livello di pagamento a cui le share si avvicinano, ma il buffer non risulta essere in drastico declino come in SMPPS. Cionondimeno, anche questo buffer raggiungerà sicuramente livelli molto bassi, oltre al fatto che non è resistente al pool-hopping.

\section{Attacchi}

\subsection{Pool-Hopping}

Una pool vulnerabile a tale attacco possiede caratteristiche di attrattività per il mining, in termini di guadagno atteso, varianza e tempo di maturazione, che variano nel tempo. Il pool-hopping è quindi una tecnica per sfruttare le circostanze favorevoli che consiste nel collegarsi ad una pool quando l'attrattiva è alta ed allontanarsene quando è bassa, portando grandi benefici al pool-hopper a discapito di quei minatori che rimangono collegati anche nei momenti di minore attrattività.
Essere costantemente collegati ad una pool vulnerabile è dunque svantaggioso, ma uno scenario in qui il pool-hopping è la normalità è altrettanto insostenibile: prima o poi ogni pool vulnerabile entrerà in uno stato tale da risultare meno attrattiva di una non vulnerabile e quando ciò accade tale pool è destinata a morte certa. L'unico sistema sostenibile è quello in cui ogni minatore opera in solitario o in una pool invulnerabile o quantomeno estremamente resistente al pool-hoppin.\\\\
Nella sua forma più tradizione il pool-hopping si attua sfruttando la ricompensa più elevata elargita per aver minato in round brevi nelle pool proporzionali e nelle pool Slush.
Può anche essere attuato nelle pool che utilizzano una qualche forma di buffer: minore il buffer, minore l'attrattiva. Nelle SMPPS i pool-hoppers possono ridurre il loro tempo di maturazione collegandosi solo nei momenti in cui il buffer risulta positivo,
In alcune implementazioni ingenue basate su punteggi che tengono conto di fattori temporanei (e non unicamente su shares e blocchi), l'attacco è reso possibile in base alle fluttuazioni dell'hashrate complessivo della pool. Generalmente è più profittevole collegarsi quando l'hashrate attuale è più alto della media.

\subsection{Sottrazione di blocchi}

Con l'attuale implementazione del protocollo, un minatore è in grado di riconoscere in modo autonomo se una share da lui trovata è o meno un blocco. Un attaccante potrebbe dunque inviare ad una pool solo le share che non sono blocchi per intascare la relativa ricompensa da parte della pool, ma trattenere per se o dilazionare l'invio nel caso in cui la share sia un blocco valido. Questo comportamento può essere usato per portare due tipi di attacchi, sabotaggi e imboscate.

\subsection{Sabotaggi}

L'attacco più semplice, in cui l'attaccante non invia mai la share/blocco trovata.
In un sistema di ricompensa senza rischio per l'operatore, ogni partecipante, attaccante compreso, perde una parte delle sua ricompensa uguale alla porzione di hashrate dell'attaccante, ovvero in media ogni minatore riceve $(1-f)\left(1-\frac{h}{H}\right)pB$ a share. La perdita può essere significativa, ma dato che è difficile da rilevare potrebbe non causare una fuga dalla pool o altri danni a lungo termine.
Se il sistema di ricompensa prevede un rischio per l'operatore, l'intera perdita ricade sulle sue spalle. In media egli guadagnare $\left(f-\frac{h}{H}\right)pB$ per ogni share e, dato che $f$ è solo una piccola percentuale, il risultato potrebbe benissimo essere negativo, portando la pool alla bancarotta.

\subsection{Imboscata}

In questo vantaggioso attacco si ritarda l'invio del blocco appena trovato e si sfrutta la propria conoscenza dell'imminente ritrovamento da parte di altri per focalizzare il proprio lavoro dove più conviene.
Se $T_0 = 10$ min. è il tempo medio necessario per trovare un blocco, si assuma che esistano $m$ pool PPLNS con parametro finestra $X=1$ e hashrate $H$, e che l'attaccante lavori contemporaneamente in ogni pool con hashrate $h$ (\emph{fase di attesa}). Ogniqualvolta trova un blocco, il minatore concentra tutta la sua potenza di calcolo sulla pool in cui lo ha trovato (\emph{imboscata}) e, dopo un certo tempo $T$ invii il blocco e ricominci a minare in tutte le pool tornando alla fase di attesa. Se un altro blocco è trovato durante la fase di attacco (rendendo quindi il suo blocco invalido), torna alla fase di attesa.
Le probabilità di avere successo nell'imboscata (ovvero le probabilità che non venga trovato un altro blocco durante l'intervallo $T$) è $e^\frac{-T}{T_0} \approx 1 - \frac{T}{T_0}$. Durante l'imboscata troverà in media $mhT2^{-32}$ shares ognuna delle quali vale circa $pB$ più della norma, perché verrà ricompensato sia per il blocco imminente che sta per inviare sia per tutti i blocchi futuri. Comunque, ritardare l'invio del blocco fa decadere le shares esistenti nella pool per un valore totale approssimativamente di $\frac{pBhT}{H}(H + (m-1)h) \approx pBhT2^{-32}$. Nel caso l'imboscata fallisca, non ricaverà nessun extra ma il valore delle shares sarà comunque diminuito, causandogli una perdita di circa $pBhT2^{-32}$ dato che il tempo per trovare il prossimo blocco è in media approssimabile a $\frac{T}{2}$.
A conti fatti, il valore atteso dall'imboscata è dunque
\[pBh2^{-32}\left(\left(1-\frac{T}{T_0}\right)\left(mT-T\right) - \frac{T}{T_0}\frac{T}{2}\right)\]
Se $T=\frac{m-1}{2m-1}T_0$ tale valore raggiunge il suo massimo $pBh2^{-32}\frac{(m-1)^2}{4m-2}T_0 \approx pBh2^{-34}mT_0$. L'hashrate totale della rete è $H_0=\frac{2^{32}D}{T_0}$, il che porta il valore atteso ad essere equivalente a $\frac{mhB}{4H_0}$, dove $mh$ è l'hashrate dell'attaccante.
Ogni share trovata dall'attaccante ha un probabilità $p$ di essere un blocco valido e rendere fattibile un'imboscata, per cui la ricompensa attesa per ogni share risulta essere $pB\left(1 + \frac{mh}{4H_0}\right)$.

\subsection{Contromisura: Share Offuscate}

Una soluzione che prevede la modifica del protocollo Bitcoin consiste nella creazioni di share offuscate, ovvero share che, quando trovate dai minatori, non possono essere identificate come blocchi validi.    Rosenfeld propone la seguente implementazione per le share offuscate.
\begin{itemize}
    \item Ogni blocco ha tre campi associati:\verb|SecretSeed|, \verb|ExtraHash| e \verb|SecretHash|. \verb|ExtraHash| ] è l'hash di \verb|SecretSeed|, sarà parte dell'header del blocco ed uno dei campi utilizzati per calcolare l'hash del blocco. \verb|SecretHash| è l'hash della concatenazione del blocco dell'hash con \verb|SecretSeed|.
    \item Perché un blocco sia valido, invece di richiedere che il suo hash sia minore di $\frac{2^256}{2^32 D}$, si richiede che l'hash del blocco sia minore di $\frac{2^256}{2^32}$ e che \verb|SecretHash| sia minore di $\frac{2^256}{D}$.
\end{itemize}
L'operatore di una pool sceglierà \verb|SecretSeed| e lo manterrà segreto, calcolerà \verb|ExtraHash| e lo invierà ai minatori insieme agli altri campi che compongono l'hash del blocco. I minatori possono calcolare l'hash del blocco, verificare che sia minore di $\frac{2^256}{2^32}$ (il che accade con una probabilità di $2^{-32}$) e in tal caso inviarlo come una share. Non hanno idea se quella share sia un blocco o meno, in quanto non hanno accesso a \verb|SecretSeed| e non possono calcolare \verb|SecretHash|. L'operatore che riceve le share conosce \verb|SecretSeed|, calcola \verb|SecretHash| e se esso è inferiore a $\frac{2^256}{D}$ (probabilità $p$), allora la share è un blocco valido che verrà inoltrato nella rete.


%TODO: forse potrei aggiungere l'ultimo capitolo sui metodi di ricompensa non standard, in caso più avanti
