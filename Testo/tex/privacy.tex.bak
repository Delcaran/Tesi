\chapter{Privacy}\label{privacy}

Uno degli obiettivi del design di Bitcoin è l'anonimato dell'utente. Il paragone più appropriato è quello con i conti in banca della Svizzera. Ogni utente bitcoin può infatti possedere più di un portafogli (ovvero di una coppia di chiavi pubblica e privata) e per ogni portafogli più di un conto/indirizzo (che altro non è che una stringa unica generata grazia alla coppia di chiavi) e tutte le transazioni si basano unicamente sull'indirizzo. Non esiste quindi nessun modo per risalire al proprietario di un dato indirizzo bitcoin basandosi unicamente sulla struttura della rete.

Esistono ovviamente diverse tecniche sia per ridurre il livello di privacy, ad esempio tramite il furto delle chiavi o un'analisi statistica degli input e degli output delle transazioni, sia per aumentarlo, magari creando un diverso portafoglio per ogni conto che si desidera creare.

\section{Analisi quantitativa della privacy}\label{analisi-quantitativa-della-privacy}

Ma come si fa a misurare il livello di privacy offerto da Bitcoin? In questa sezione si discuteranno alcune metriche arbitrarie create appositamente che trattano i vari aspetti dell'anonimato nella rete Bitcoin.

Essendo una analisi quantitativa, è necessario fornire una definizione formale per i termini fin qui usati in modo più o meno descrittivo. Sotto tale ottica verrano quindi proposte alcune definizioni formali, la prima delle quali è il concetto portante della rete:

Transazione:
\[\tau(a_{\textrm{S}} \rightarrow a_{\textrm{R}}) = \{ \textrm{source}, B, a_{\textrm{R}}, \textrm{SIG}_{\textrm{sk}_{a_{\textrm{S}}}}\left(\textrm{source}, B, a_{\textrm{R}}\right) \} \]
definisce una transazione che intercorre tra i due indirizzi $a_{\textrm{S}}$ e $a_{\textrm{R}}$, in cui $\textrm{SIG}_{\textrm{sk}_{a_{\textrm{S}}}}$ è la firma digitale creata utilizzando la chiave privata $\textrm{sk}_{a_\textrm{S}}$ corrispondente alla chiave pubblica associata all'indirizzo $a_\textrm{S}$. $B$ è la quantità di BTC trasferite e $\textrm{source}$ è un riferimento alla più recente transazione da cui $a_\textrm{S}$ ha ottenuto le $B$ BTC.

Al fine dell'analisi, assumiamo la situazione tipica della rete Bitcoin, in cui ogni singolo utente dispone di diversi indirizzi a lui associati. Mentre questa può sembrare una forzatura, in realtà non lo è affatto. Come abbiamo detto in precedenza, ogni transazione contiene un indirizzo di ritorno per il resto. Tale indirizzo viene definito \emph{indirizzo ombra} ed è creato automaticamte senza l'intervento dell'utente. Per cui ogni utente possiede almeno due indirizzi: quello creato al momento della creazione del portafogli e l'indirizzo ombra.

\subsection{Il modello antagonistico}\label{il-modello-antagonistico}

Gli algoritmi proposti consistono nell'osservazione del log pubblico di Bitcoin (\emph{pubLog}) durante un periodo $\Delta t$. Durante questo periodo, $n_U $ utenti (dall'insieme $U = \{u_1, \ldots, u_{n_U}\}$) contribuiscono al \emph{pubLog} con l'insieme di indirizzi $A = \{a_1, \ldots, a_{n_A}\}$. Si ha poi l'insieme delle transazioni $T = \{ \tau_1 (S_1 \rightarrow R_1), \ldots , \tau_{n_T}(S_{n_T} \rightarrow R_{n_T}) \} $ in cui $\tau_i (S_i \rightarrow R_i)$ descrive una singola transazione con ID univoco pari a $i$, e con $S_i$ e $R_i$ l'insieme degli indirizzi di mittente e destinatario rispettivamente. Viene introdotto anche un avversario $\adversary$ interessato ad ottenere informazioni su tutte le transazioni e gli indirizzi appartenenti ad un insieme di utenti Bitcoin. Si assume quindi che $\adversary$ sia un nodo legittimo della rete, abbia accesso a \emph{pubLog}, ad alcuni indirizzi di commercianti resi pubblici e altre informazioni statistiche pubblicamente disponibili. Inoltre si assume anche che gli utenti siano incoraggiati a cambiare frequentemente i loro indirizzi, spostando le loro monete da un indirizzo all'altro. Questa è una delle abitudini consigliate da Nakamoto.

\subsection{Quantificazione della Privacy}\label{quantificazione-della-privacy}

Esistono (almeno) due nozioni distinte di privacy per la rete Bitcoin.

\emph{Activity unlinkability}: Un avversario $\adversary$ non dovrebbe essere in grado di associare due indirizzi distinti (\emph{address unlinkability}) o transazioni (\emph{transaction unlinkability}) ad un utente scelto dell'avversario stesso.

\emph{Profile indistinguishability}: L'avversario non deve essere in grado di ricostruire i profili (insieme di indirizzi e transazioni) di tutti gli utenti del \emph{pubLog}. Questa nozione di privacy è più forte della precedente, in quanto riguarda l'intera rete e non solo un utente. Inoltre i due profili (per transazioni e per indirizzi) non sono equivalenti quando si tratta di modellare il profilo di un utente, in quanto è possibile indovinare correttamente gli indirizzi di utenti coinvolti in poche transazioni ma sbagliare nel caso di pochi indirizzi coinvolti in molte transazioni.

Vengono definiti due algoritmi \emph{AddUnl} e \emph{ProfInd} che implementano una sorta di sfida in cui l'attaccante tenta di violare le due nozioni di privacy sopra descritte. Il risultato sarà una quantificazione delle nozioni di privacy nei termini del vantaggio che $\adversary$ possiede per vincere queste sfide nei confronti di un avversario $\adversaryrnd$ che tenta di vincere le stesse sfide rispondendo in modo casuale. Ipotizziamo che $\adversary$ abbia accesso completo a \emph{pubLog} e che sia $\adversary$ che $\adversaryrnd$ abbiano accesso ad una base di conoscenza comune $\knowa$ che contengono informazioni verificate su un sottoinsieme di indirizzi e i relativi proprietari.

\subsubsection{Address Unlinkability}\label{address-unlinkability}

Il seguente algoritmo descrive il meccanismo con cui avviene la sfida per la address unlinkability. In questo algoritmo si utilizza $\adversary$ come un generico avversario, in quanto per i calcoli di quantificazione l'algoritmo verrà eseguito sia da $\adversary$ che da $\adversaryrnd$. Si comincia con $\adversary$ che seleziona in modo causale un indirizzo presente in pubLog e lo invia ad uno sfidante $\challenger$ (che si assume sia a conoscenza delle corrette correlazioni utenti-indirizzi). Se l'indirizzo scelto da $\adversary$ è l'unico che appartiene all'utente, $\adversary$ vince la sfida. Altrimenti $\challenger$ scegli un bit casuale $\mathit{b}$. Se $\mathit{b} = 1$ allora $\challenger$ sceglie un nuovo indirizzo tra quelli disponibili in pubLog che appartenga allo stesso utente del primo indirizzo, altrimenti il nuovo indirizzo verrà scelto tra quelli in pubLog che non appartengono al proprietario del nuovo indirizzo. L'indirizzo scelto insieme al precedente indirizzo vengono inviati ad $\adversary$, il quale stima (con un algoritmo di sua scelta, ininfluente per la sfida) se i due indirizzi che ha ricevuto appartengono o meno allo stesso utente, e memorizza il suo risultato nel bit $\mathit{b}'$. Se $\adversary$ ha indovinato, ovvero se $\mathit{b} = \mathit{b}'$, allora $\adversary$ vince la sfida. L'algoritmo è visibile in \ref{addunl_alg}.

\input{./tex/AddUnl.tex}

Stabiliamo che Bitcoin soddisfa il principio di \emph{Address Unlinkability} se, per ogni avversario $\adversary$ (che ha un ben preciso algoritmo per rispondere alla domanda di $\challenger$) e per ogni coppia di indirizzi scelti dall'algoritmo, $\adversary$ ha solo un piccolo vantaggio rispetto ad un avversario come $\adversaryrnd$ che risponde a caso alla domanda posta da $\challenger$. Formalmente diciamo che Bitcoin soddisfa la Address Unlinkability se:

\begin{equation*}
\Pr [ \mathit{b}' \leftarrow \adversary \left(\text{pubLog}, \knowa \right) : \mathit{b} = \mathit{b}' ] - \Pr [\mathit{b}' \leftarrow \adversaryrnd \left(\knowa \right) : \mathit{b} = \mathit{b}' ] \leq \varepsilon
\end{equation*}

con $\varepsilon$ trascurabile.

\paragraph{Quantificazione di Address Unlinkability}\label{quantificazione-di-address-unlinkability}

Sfruttando i risultati ottenuti dalla sfida, è possibile stimare il \emph{grado} con cui gli indirizzi Bitcoin possono essere collegati ad uno stesso utente. Verranno definite alcune strutture matematiche necessarie per i calcoli.

\[E_\text{link} [i, j] = \{p_{i,j}\}_{i,j \in [1, n_A ]}\]

Rappresenta una matrice $n_A \times n_A$ in cui ogni argomento esprime la probabilità $p_{i,j}$ stimata da $\adversary$ che l'indirizzo $a_i$ appartenga allo stesso utente dell'indirizzo $a_j$ (in simboli, $a_i \sameuser a_j$). Si definisce poi una matrice $n_A \times n_A$ che mantenga le informazioni sulle reali connessioni tra gli indirizzi:

\[\text{GT}_\text{link} [i,j] = \begin{cases} 1 &\text{se } a_i \sameuser a_j \\ 0 &\text{altrimenti} \end{cases}\]

Date queste due strutture, si definisce l'errore commesso da $\adversary$ nella sua stima come la \emph{distanza di Manhattan} che intercorre tra $E_\text{link} [i,*]$ e le vere associazioni di $a_i$ con tutti gli indirizzi in pubLog:

\[ \begin{aligned} \text{Er}_{\adversary} &= \| E_\text{link} [i, *] - \text{GT}_\text{link} [i,*]\|_1 \\
   &= \sum_x | E_\text{link} [i, x] - \text{GT}_\text{link} [i,x] | \quad \text{ con } x \in [1, n_A]
   \end{aligned}\]

Si può dunque determinare il successo di $\adversary$ per AddUnl come il massimo del suo errore:

\[ \begin{aligned} \text{Succ}_{\adversary} &= \max_{\forall a_i \not\in \knowa} \left(\| E_\text{link} [i, *] - \text{GT}_\text{link} [i,*]\|_1 \right) \\
   &= \max_{\forall a_i \not\in \knowa}\left(\sum_x | E_\text{link} [i, x] - \text{GT}_\text{link} [i,x] |\right) \quad \text{ con } x \in [1, n_A]
   \end{aligned} \]

Stesse condizioni devono essere fatte per l'avversario con criterio di decisione casuale, $\adversaryrnd$. Mantenendo uguale $\text{GT}_\text{link} [i,j]$ è necessario definire la matrice $E^{\mathcal{R}}$\_come segue:

\[E^{\mathcal{R}}_\text{link} [i, j] = \begin{cases} \pi_{i,j} &\text{ se } \langle a_i, a_j \rangle \in \knowa \\ \rho + \rho(1-\rho)\tfrac{1}{2} &\text{ altrimenti} \end{cases}\]

Dove $\pi_{i,j}$ rappresenta la probabilità che gli indirizzi $a_i$ e $a_j$ appartengano allo stesso utente secondo $\knowa$, mentre $\rho$ è la frazione di indirizzi in $\{\text{pubLog} \smallsetminus \knowa\}$ che non può essere associata ad altri indirizzi (il che capita quando un utente ha solo un indirizzo)\footnote{l'esistenza degli indirizzi ombra   non ha al momento rilevanza, ma più avanti $\rho$ diventerà   trascurabile a causa della loro presenza.}. Per le coppie di indirizzi non incluse in $\knowa$ tale probabilità è $\rho + \rho(1-\rho)\tfrac{1}{2}$.

Le altre formule vengono mantenute uguali sostituendo $E^{\mathcal{R}}_\text{link} [i, j]$ a $E_\text{link} [i, j]$. Il grado di address unlinkability risulta quindi essere il grado di successo aggiuntivo che $\adversary$ può ottenere da pubLog in comparazione con $\adversaryrnd$, chiamato $Link^{\text{abs}}_{\adversary}$
%FIXME   non ho la minima idea di cosa sia la versione normalizzata.

\[ \begin{aligned} Link^{\text{abs}}_{\adversary} &= \text{Succ}_{\adversary} - \text{Succ}_{\adversaryrnd} \\
   &= \frac{\text{Succ}_{\adversary} - \text{Succ}_{\adversaryrnd}}{\text{Succ}_{\adversaryrnd}} \quad \text{ in versione normalizzata}
   \end{aligned}\]

\subsubsection{User Profile Indistinguishability}\label{profile-indistinguishability}

L'impossibilità di ricostruire i profili di tutti gli utenti è una proprietà molto più forte rispetto all'impossibilità di associare due indirizzi diversi ad uno stesso utente.

L'algortimo di sfida \emph{ProfInd}\label{profind_alg} viene costruito nel modo seguente.
Lo sfidante $\challenger$ invia ad $\adversary$ il numero $n_U$ di utenti in $\{\text{pubLog} \smallsetminus \knowa\}$, che risponde con $n_U$ insiemi di indirizzi (o transazioni) e con la matrice $E_\text{prof} = {\{g_i\}}^{n_U}_{i=1}$ rappresentante la stima fatta da $\adversary$ sui profili degli utenti nel sistema.
Come per l'algoritmo precedente, definiamo $\text{GT}_\text{prof} = {\{\text{gt}_i\}}^{n_U}_{i=1}$ che rappresenta le vere associazioni tra indirizzi (o transazioni) e utenti, per cui:

\[
	\text{GT}_\text{prof} = \begin{cases}
		{\{a_{u_i}\}}^{n_U}_{i=1} &\text{ per profili basati su indirizzi} \\
		{\{\tau_{u_i}\}}^{n_U}_{i=1} &\text{ per profili basati su transazioni}
	\end{cases}
\]

dove $a_{u_i}$ e $\tau_{u_i}$ rappresentano insiemi di indirizzi/transazioni per l'utente $u_i$.
Ovviamente, $\adversary$ vince la sfida se indovina correttamente il profilo, ovvero $E_\text{prof} \equiv \text{GT}_\text{prof}$.

\input{./tex/ProfInd.tex}

Diciamo che un sistema soddisfa la proprietà di \emph{Profile Indistinguishability} se non esiste nessun avversario $\adversary$ in grado di vincere \emph{ProfInd} con una probabilità migliore dell'avversario che risponde casualmente $\adversaryrnd$, ovvero:

\[
	\begin{aligned}
		\forall \adversary: &\Pr [E_\text{prof} \leftarrow \adversary(\text{pubLog}, n_U): E_\text{prof} \equiv \text{GT}_\text{prof}] - \\
		&\Pr [ E^\mathcal{R}_\text{prof} \leftarrow \adversaryrnd(n_U) : E^\mathcal{R}_\text{prof} \equiv \text{GT}_\text{prof} ] \leq \varepsilon
	\end{aligned}
\]

\paragraph{Quantificazione di Profile Indistinguishability}\label{quantificazione-di-profile-indistinguishability}

Anche in questa stima come per la precedente, la quantificazione dipende dal confronto tra la stima di $\adversary$ e i dati reali.
Definiamo quindi la similitudine tra $E_\text{prof}$ e $\text{GT}_\text{prof}$ come la funzione $Sim(E_\text{prof}, \text{GT}_\text{prof})$, i cui valori appartengono all'insieme $[0, 1]$.
Come per la address unlinkability, misuriano la profile indistinguishability contro $\adversary$ stimando il grado con cui $\adversary$ è in grado di stilare un profilo utente corretto, ovvero misurando il vantaggio che $\adversary$ ha rispetto a $\adversaryrnd$ nell'avvicinarsi a $\text{GT}_\text{prof}$:

\[ \text{Prof}_\adversary = \text{Sim}(E_\text{prof}, \text{GT}_\text{prof}) - \text{Sim}(E^\mathcal{R}_\text{prof}, \text{GT}_\text{prof}) \]

Per quantificare $Sim(E_\text{prof}, \text{GT}_\text{prof})$ e $\text{Prof}_\adversary$ è necessario sfruttare alcune metriche per calcolare le distanze basate sull'entropia, la \gls{nmi} e la \gls{ami}.
La \gls{nmi} valuta la similarità di due raggruppamenti degli stessi oggetti e assume valori tanto più alti (il massimo è 1) tanto più i due raggruppanti sono identici.
La \gls{ami}, dati due raggruppamenti $G_1$ e $G_2$, si avvicina allo 0 quando $G_1$ risulta simile ad un raggruppamento casuale, mentre si avvicina a 1 quando $G_1 = G_2$. Quindi \gls{ami} valuta direttamente il vantaggio che ha $\adversary$ nel vincere la sfida di \emph{ProfInd}.

Nel caso di profili basati sugli indirizzi, \gls{nmi} e \gls{ami} sono calcolate come segue:

\[\text{NMI} = \frac{\mathcal{I} \left(E_\text{prof}, \text{GT}_\text{prof}\right)}{\max \left(H \left(E_\text{prof}\right),H \left(\text{GT}_\text{prof}\right)\right)} \]
\[\text{AMI} = \frac{\mathcal{I} \left(E_\text{prof}, \text{GT}_\text{prof} - \mathcal{E}\right)}{\max \left(H \left(E_\text{prof}\right),H \left(\text{GT}_\text{prof}\right)\right) - \mathcal{E}}\]
dove:
\[ \mathcal{I} \left(E_\text{prof}, \text{GT}_\text{prof}\right) = \sum^{n_U}_{i=1} \left( \sum^{n_U}_{i=1} \left( \frac{n_{\left(i,j \right)}}{n_A} \log\left(\frac{n_{\left(i,j\right)} \cdot n_A}{n_{\left(i,*\right)}n_{\left(*,j\right)}}\right)\right)\right) \]
\[ H\left(E_\text{prof}\right) = - \sum^{n_U}_{i=1} \left(\frac{n_{\left(i,*\right)}}{n_A} \log\left(\frac{n_{\left(i,*\right)}}{n_A}\right)\right) \]
\[ H\left(\text{GT}_\text{prof}\right) = - \sum^{n_U}_{j=1} \left(\frac{n_{\left(*,j\right)}}{n_A} \log\left(\frac{n_{\left(*,j\right)}}{n_A}\right)\right) \]
\[
	\scriptstyle \mathcal{E} = \sum^{n_U}_{i=1} \left(
	    \sum^{n_U}_{j=1} \left(
	        \sum_{n \in \mathcal{M}} \left(
	            \frac{n}{n_A} \log \left(
	                \frac{n_A n}{n_{\left(i, *\right)} n_{\left(*, j \right)}}
	            \right) \frac{n_{\left(i, *\right)}! n_{\left(*, j\right)}! \left(
	                n_A - n_{\left(i, *\right)}
	            \right)!\left(
	                n_A - n_{\left(*, j\right)}
	            \right)!}
	            {n_A!\left(n_{\left(i, *\right)} - n\right)!
	                    \left(n_{\left(*, j\right)} - n\right)!
	                    \left(n_A - n_{\left(i, *\right)} - n_{\left(*, j\right)} - n \right)!}
	            \right)
	        \right)
	    \right)
\]
\[ \mathcal{M} = \left[ \max \left( n_{\left(i,*\right)} + n_{\left(*,j\right)} - n_A, 0\right), \min\left(n_{\left(i,*\right)}, n_{\left(*,j\right)}\right)\right] \]

%TODO tradurre "expected mutual information"
In queste formule, $n_A$ è il numero di indirizzi Bitcoin, $n_{\left(i,j\right)}$ è il numero di indirizzi di $u_i$, che vengono assegnati al gruppo $g_j$, $n_{\left(i,*\right)}$ e $n_{\left(*,j\right)}$ sono il numero di indirizzi di $u_i$ e $g_i$ rispettivamente. $\mathcal{E}$ rappresenta l'informazione mutuale attesa tra il raggruppamento $\text{GT}_\text{prof}$ e il raggruppamento casuale di indirizzi $E^\mathcal{R}_\text{prof}$.
Si possono ottenere risultati simili per calcolare \gls{nmi} e \gls{ami} nel caso di profili basati sulle transazioni.

È importante far presente che, sebbene \gls{nmi} e \gls{ami} siano efficaci per rappresentare il successo di $\adversary$ nella creazione di un profilo per tutti gli utenti della rete, non sono in grado di misurare il successo dell'avversario nel creare un profilo per un utente specifico.

\section{Valutazione della privacy in Bitcoin}\label{valutazione-della-privacy-in-bitcoin}

Vediamo ora come il nostro avversario, dato pubLog, può raccogliere informazioni sugli utenti Bitcoin sfruttando alcune proprietà delle attuali implementazioni del client Bitcoin.
Grazie ad un simulatore vedremo poi quanto il modello precedentemente descritto risulti valido data la conoscenza acquisita.

\subsection{Euristiche per sfruttare il client}

\paragraph{Transazioni multi-input}

Quando per una transazione non è possibile sfruttare l'output di una singola transazione precedente, è necessario usare come input più di una transazione.
I client scelgono un insieme di BTC dal portafoglio dell'utente in modo che il loro valore totale sia quello richiesto dalla transazione ed effettuano così una transazione multi-input.
Dato che le BTC sono nel portafogli dell'utente, se tali BTC sono prese da indirizzi diversi, allora tali indirizzi appartengono tutti allo stesso utente.

\paragraph{Indirizzi ombra}

Come detto in precedenza, gli indirizzi ombra vengono creati dal client per raccogliere l'eventuale resto delle transazioni.
Immaginando quindi una transazione con un input e due output, si può ragionevolmente stabilire quale dei due indirizzi sia quello ombra appartenente allo stesso utente che ha inviato la transazione. L'indirizzo ombra sarà infatti creato sul momento, dunque sarà l'indirizzo che non è presente nel pubLog in data precedente alla transazione.
Questo è valido se si assume che gli utenti della rete siano attivi (abbiano fatto almeno una transazione) e che il client non consenta di creare una transazione con più indirizzi in output.

Per valutare la bontà delle euristiche, creiamo un parser che analizzi alcuni blocchi e raggruppi gli indirizzi in cluster di indirizzi generici (GA) basati sulle euristiche.

Lanciando il parser sui primi 140000 blocchi della blockchain (ovvero i blocchi creati fino ad Agosto 2011), il parser restituisce 1632648 indirizzi unici.
Utilizzando la prima euristica, tali indirizzi possono essere classificati in 1069699 distinti GA, mentre con la seconda euristica i numeri di distinti GA scende a 693051.
Dato che a Settembre 2011 esistevano circa 60000 utenti Bitcoin, i risultati ottenuti indicano che è stato raggruppato circa il 58\% degli indirizzi Bitcoin con una media di 11.55 indirizzi per cluster.
Ciò dimostra che raccogliendo informazioni con queste euristiche, il vantaggio di $\adversary$ per AddUnl è considerevole.

\subsection{Analisi basata sul comportamento}

Ora come ora, esistono molteplici client per la rete Bitcoin, e anche quello ufficiale va spesso incontro a modifiche e miglioramenti.
Quello che difficilmente cambia è il comportamento degli utenti.
Esistono alcune tecniche di raggruppamento basate sul comportamento che $\adversary$ può sfruttare, come ad esempio gli algoritmi \gls{kmc} e \gls{hac}.
Definiamo $U$ come l'insieme di tutti gli utenti Bitcoin, e $\left( \text{GA}_1 , \ldots , \text{GA}_{n_\text{GA}} \right)$ i raggruppamenti ottenuti da $\adversary$ applicando le due euristiche precedentemente descritte a pubLog.
Con questi dati, l'obiettivo di $\adversary$  è ottenere un gruppo di clusters di indirizzi $E_\text{prof} = \{ g_1 , \ldots , g_{n_U} \}$ che approssimi il più possibile $U$.
Dato che ogni GA è "posseduta" da esattamente un utente, la stima dell'assegnamento di ogni GA può essere modellata con una variabile $z_i$ tale che $z_i = k \iff \text{GA}_i \text{ appartiene a } g_k$.
L'algoritmo \gls{hac} assume che inizialmente ogni GA rappresenti un utente separato ($\{ z_i = i \}^{n_\text{GA}}_{i=1}$) e calcola valori di similitudine per ogni coppia di cluster. I cluster con elevata similarità vengono raggruppati insieme e il processo si ripete sui nuovi raggruppamenti, fermandosi quando il numero di raggruppamenti è esattamente uguale al numero di utenti $n_U$.
A questo punto si avvia \gls{kmc}, inizializzato con l'output di \gls{hac}, il quale assume che ogni utente sia rappresentato dal punto centrale di ogni raggruppamento. L'algoritmo tenta di minimizzare la distanza tra i GA e i cluster a cui essi sono stati assegnati, ricalcolando ad ogni round sia il centro dei cluster sia la distanza GA-cluster.

Nella loro implementazione, gli autori di \cite{user-privacy} hanno rappresentato ogni transazione all'interno delle GA con tre punti:
\begin{enumerate}
    \item
        L'orario in cui la transazione ha avuto luogo.
    \item
        Gli indici dei diversi GA che appaiono all'interno della transazione come mittenti o destinatari.
    \item
        La quantità di BTC spese nella transazione.
\end{enumerate}
$\tau_x$ identifica l'insieme delle transazioni di $\text{GA}_x$, e il grado di similitudine tra due cluster $\text{GA}_i$ e $\text{GA}_j$ è rappresentato dal coseno di similitudine \footnote{Tecnica euristica che misura la differenza tra due vettori, spesso usata per il confronto dei testi} tra le liste $\tau_i$ e $\tau_j$, ovvero:
\[
\text{Sim}^\text{hac} \left( \text{GA}_i , \text{GA}_j \right) = \frac{\sum_{\forall \tau \in \tau_i \cap \tau_j} \left( f_{\left( \tau, i \right)} \cdot f_{\left( \tau, j \right)} \right) }{ \| \tau_i \|_2 \cdot \| \tau_j \|_2 }
\]
dove $f_{\left( \tau, x \right)}$ sono le occorrenze dell'oggetto $\tau$ nel vettore $\tau_x$.
Da ciò si deriva la metrica per la distanza in \gls{kmc}:
\[
\text{Dist}^\text{kmc} \left( \text{GA}_i , g_k \right) = \frac{2}{ 1 + text{Sim}^\text{hac} \left( \text{GA}_i , g_k \right) } - 1
\]
L'implementazione tiene anche conto di alcune restrizioni imposte dal mondo reale. In particolare, dato che gli utenti non possono fisicamente essere in due posti allo stesso tempo, non possono partecipare in due distinti (fisicamente) scambi di beni allo stesso tempo.

\subsection{Simulazione: utilizzo di Bitcoin in ambiente universitario}

Per verificare i loro modelli, i ricercatori hanno simulato l'utilizzo di Bitcoin per le transazioni quotidiane da parte degli utenti del Dipartimento di Informatica all'ETH di Zurigo con l'assunzione che i negozi nei dintorni della facoltà accettino BTC come valuta.

\paragraph{Impostazione della sperimentazione}

%TODO figura 1 in \cite{user-privacy}
Il simulatore riceve in input un file XML come input e output:
\begin{itemize}
    \item un log che descrive gli eventi simulati, ovvero la \emph{base di verità}.
    \item il pubLog risultante dalla simulazione.
\end{itemize}
I file XML di configurazione contengono tutti i parametri necessari alla simulazione, come il numero di utenti, il numero di nodi che generano i blocchi (i \emph{miners}), il tempo di simulazione, la difficoltà della generazione dei blocchi, le configurazioni per creare i profili utente e i venditori/acquirenti.
Gli output del simulatore vengono utilizzati per valutare il successo di $\adversary$: un parser Perl utilizza i blocchi Bitcoin simulati come input ed effettua una prima classificazione degli indirizzi simulati in GA in base alle due euristiche descritte.
Questo output prefiltrato viene dato in pasto agli algoritmi \gls{kmc} e \gls{hac} (entrambi implementati in C).
L'output di tali algoritmi viene infine comparato con la base di verità tramite un secondo script Perl che calcola il successo di $\adversary$ sulle sfide AddUnl e ProfInd.

La configurazione utilizzata rappresenta uno scenario realistico per gli studenti e lo staff del Dipartimento di Informatica dell'Università di Zurigo durante il semestre autunnale del 2012.
Si è simulato un numero variabile di utenti dei quali il 5.2\% sono \emph{Professori}, il 42.0\% fanno parte dello \emph{Staff} e il restante 52.8\% sono \emph{Studenti}. Vengono considerati in tutto 6 eventi distinti con diverse varianti:
\begin{itemize}
    \item Pranzo e cena (12 varianti).
    \item Acquisto di alimentari (2 varianti).
    \item Acquisto da distributori automatici (4 varianti).
    \item Shopping online (5 varianti).
    \item Acquisto di libri (2 varianti).
    \item Baratto con altri utenti.
\end{itemize}
Ad ogni utente viene assegnata una probabilità per ognuna delle varianti in accordo alla categoria (Professore, Staff, Studente) a cui appartiene.
Per ogni evento vengono stabilite la frequenza con cui avviene e un range di prezzo, mentre alle varianti viene assegnato un punteggio in base alla loro popolarità. La probabilità che una variante venga selezionata è il risultato dell'interpolazione tra la frequenza degli eventi in una settimana e il punteggio della variante.
Per assicurare una grande varietà di profili utente, nella configurazione per ogni evento vengono specificati valori massimi e minimi per la frequenza, il punteggio e il prezzo. Tali limiti dipendono dalla categoria dell'utente, dall'evento e dalla variante in questione.
All'inizio della sperimentazione, gli utenti hanno meno di 10 indirizzi Bitcoin a testa. Man mano che vengono effettuate transazioni, nuovi indirizzi ombra vengono creati nei loro portafogli.
Nella configurazione è stato inoltre modellato il comportamento degli utenti attenti alla propria privacy: tali utenti periodicamente creano nuovi indirizzi nei propri portafogli e trasferiscono parte delle proprie BTC dal vecchio al nuovo indirizzo.



\begin{itemize}
\item
  an analisis of anonimity in bitcoin sistem
\end{itemize}
